# Writing Compiler Front-Ends for LLVM with Lua using Mewa

## Lead Text
LLVM IR text representation makes it possible to write a compiler front-end without being bound to an API. We can map the source text to the text of LLVM IR and use the tools of the clang compiler for further compilation steps. This opens the doors to implement compiler front-ends in different ways. Mewa tries to optimize the amount of code written. It targets single authors that would like to write a prototype of a non-trivial programming language fast, but at the expense of a structure supporting collaborative work. This makes it rather a tool for experiment than for building a product.

## Introduction

The Mewa compiler-compiler is a tool to script compiler front-ends in Lua. A compiler written with Mewa takes a source file as input and prints an intermediate representation as input for the next compilation step. The example in this tutorial uses the text format of LLVM IR as output. An executable is built using the ```llc``` command of _Clang_.

Mewa provides no support for the evaluation of different paths of code generation. The idea is to do a one-to-one mapping of program structures to code and to leave all analytical optimization steps to the backend.

For implementing a compiler with Mewa, you define a grammar attributed with Lua function calls.
The program ```mewa``` will generate a Lua script that will transform any source passing the grammar specified into an AST with the Lua function calls attached to the nodes. The compiler will call the functions of the top level nodes of the AST that take the control of the further processing of the compiler front-end. The functions called with their AST node as argument invoke the further tree traversal. The types and data structures of the program are built and the output is printed in the process.


## Goals

This tutorial starts with some self-contained examples of using the Lua library of Mewa to build the type system of your programming language. Self-contained means that nothing is used but the library. After this, the tutorial will guide you through the implementation of a compiler for a reduced and incomplete programming language.
The example program we will compile is the following:
```
$EXAMPLE:tutorial_program
```
We will compile this program with the tutorial compiler and run it in a shell. We will also look at different parts including the grammar of the language.
Finally, I will talk about the features missing in the language to give you some outlook on how to implement a compiler of a complete programming language.


## Target Audience

To understand this article some knowledge about formal languages and parser generators is helpful. To understand the examples you should be familiar with some scripting languages that have a concept of closures similar to Lua. If you have read a tutorial about LLVM IR, you will get grip on the code generation in the examples.

## Deeper Digging

For a deeper digging you have to look at the Mewa project itself and the implementation of the main example language, a strongly typed multiparadigm programming language with structures, classes, interfaces, free functions, generics, and exceptions. There exists an [FAQ](faq.md) that also tries to answer problem-solving questions.


## Tutorial, Part 1 

### Declaring a variable

Let's start with an example that is complicated but a substantial step forward. 
We print the LLVM code needed to assign a variable value to another variable. 
For this, we need to introduce **types** and **reductions**.

#### Introduction
##### Types
Types are items represented as integers. They are declared and retrieved by a string, the name of the type, and a context type.
The context type is a type declared before or 0.
Global free variables have for example no associated context type and are declared with 0 as context type. 
Types are associated with a constructor. A constructor is a value, structure or a function that describes the construction of the type.
Optionally, types are associated with arguments. Arguments are list of type/constructor pairs. Types are declared with 
```Lua
	typeid = typedb:def_type( contextType, name, constructor, parameter)
```
The ```typeid``` returned is the integer that represents the type for the typedb.
##### Reductions
Reductions are paths to derive a type from another. You can imagine the typesystem as a directed graph of vertices (types) and edges (reductions).
We will introduce some concepts that allow a partial view on this graph later. For now, imagine it as a graph.
Reductions have also an associated constructor. The constructor describes the construction of the type in the direction of the reduction from its source.
Here is an example:
```Lua
	typedb:def_reduction( destType, srcType, constructor, 1)
```
The 1 as parameter is an integer value we will explain later.
##### Resolve Type
Types can be resolved by their name and a context type having a path of reductions to the context type declaration.
##### Derive type
Types can be constructed by querying a reduction path from one type to another and constructing the type from the source type constructor
by applying the list of constructors on this path.

Let's have a look at the example:

#### Source
File examples/variable.lua
```lua
$EXAMPLE:tutorial_variable
```
#### Output
```
$EXAMOUT:tutorial_variable
```
#### Conclusion
If you got here you got already quite far. We saw the application of an operator ('=') with an argument. 
Applying a function with more than one argument is imaginable. 
The first match of the operator was our candidate match chosen as result. But selecting a match by other criteria is imaginable.
We declared a variable with a name, a concept of scope is missing here. We will look at scopes in the next example.


### The Concept of Scope

Now let's see how scope is represented in the typedb.

#### Introduction
Scope in Mewa is represented as a pair of non negative integer numbers. The first number is the start, the first scope step that belongs to the scope, the second number the end, the first scope step that is not part of the scope. Scope steps are generated by a counter with increments declared in the grammar of your language parser.
All declarations in the typedb are bound to a scope, all queryies of the typedb are bound to the current scope step. A declaration is considered to contribute to the result if its scope is covering the scope step of the query.

##### Set the current scope
```Lua
	scope_old = typedb:scope( scope_new )
```
##### Get the current scope
```Lua
	current_scope = typedb:scope()
```

The example is fairly artificial, but it shows how it works:

#### Source
File examples/scope.lua
```lua
$EXAMPLE:tutorial_scope
```
#### Output
```
$EXAMOUT:tutorial_scope
```
#### Conclusion
This was easy, wasn't it? What is missing now is how the current scope step and scope are set. I chose the variant of treating it as an own aspect. 
The function used for the AST tree traversal sets the current scope step and scope. This works for most of the cases. Sometimes you have to set the scope manually in nodes that implement declarations of different scopes, like for example function declarations with a function body in an own scope.


### Weight of Reductions

Now we have to look again at something that is a little bit puzzling. We have to assign weights to reductions. The problem is that even trivial examples of type queryies lead to ambiguity if we do not introduce a weighting scheme that memorizes a preference. Real ambiguity is something we want to detect as an error.
I came to the conclusion that it is the best to declare all reduction weights at one central place in the source and to document it well.

Let's have a look at an example without weighting of reductions that will lead to an ambiguity. 

#### Failing example
File examples/weight1.lua
```lua
$EXAMPLE:tutorial_weight1
```
#### Output
```
$EXAMOUT:tutorial_weight1
```
#### Adding weights
File examples/weight2.lua

Here is a diff with the edits we have to make for fixing the problem:
```
$EXAMPLE:tutorial_weight_diff
```
#### Output with weights
```
$EXAMOUT:tutorial_weight2
```

### Tags of Reductions

#### Failing example
```lua
$EXAMPLE:tutorial_tags1
```
#### Output
```
$EXAMOUT:tutorial_tags1
```
#### Adding tags
```
$EXAMPLE:tutorial_tags_diff
```
#### Output with tags
```
$EXAMOUT:tutorial_tags2
```


### Objects with Scope

#### Source
```lua
$EXAMPLE:tutorial_env
```
#### Output
```
$EXAMOUT:tutorial_env
```


### Control Structures, Implementing an IF

#### Source
```lua
$EXAMPLE:tutorial_control
```
#### Output
```
$EXAMOUT:tutorial_control
```








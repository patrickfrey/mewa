# Writing Compiler Front-Ends for LLVM with _Lua_ using _Mewa_

## Lead Text
_LLVM IR_ text representation makes it possible to write a compiler front-end without being bound to an API. We can map the source text to the text of _LLVM IR_ and use the tools of the _Clang_ compiler for further compilation steps. This opens the doors to implement compiler front-ends in different ways. _Mewa_ tries to optimize the amount of code written. It targets single authors that would like to write a prototype of a non-trivial programming language fast, but at the expense of a structure supporting collaborative work. This makes it rather a tool for experiment than for building a product.

## Introduction

The _Mewa_ compiler-compiler is a tool to script compiler front-ends in _Lua_. A compiler written with _Mewa_ takes a source file as input and prints an intermediate representation as input for the next compilation step. The example in this article uses the text format of _LLVM IR_ as output. An executable is built using the ```llc``` command of _Clang_.

_Mewa_ provides no support for the evaluation of different paths of code generation. The idea is to do a one-to-one mapping of program structures to code and to leave all analytical optimization steps to the backend.

For implementing a compiler with _Mewa_, you define a grammar attributed with _Lua_ function calls.
The program ```mewa``` will generate a _Lua_ script that will transform any source passing the grammar specified into an _AST_ with the _Lua_ function calls attached to the nodes. The compiler will call the functions of the top-level nodes of the _AST_ that take the control of the further processing of the compiler front-end. The functions called with their _AST_ node as argument invoke the further tree traversal. The types and data structures of the program are built and the output is printed in the process.

## Goals

We start with a tutorial of the **typedb** library of _Mewa_ for _Lua_ with some self-contained examples. Self-contained means that nothing is used but the library. The examples are also not dependent on each other. This allows you to continue reading even if you did not understand it completely and to return later.

After this, this article will guide you through the implementation of a compiler for a simple programming language missing many features.
The example program we will compile is the following:
```
$EXAMPLE:tutorial_program
```
We will compile this program with the our example compiler and run it in a shell. We will also look at different parts including the grammar of the language.
Finally, I will talk about the features missing in the language to give you some outlook on how to implement a compiler of a complete programming language.

## Target Audience

To understand this article some knowledge about formal languages and parser generators is helpful. To understand the examples you should be familiar with some scripting languages that have a concept of closures similar to _Lua_. If you have read an introduction to [LLVM IR](links.md), you will get grip on the code generation in the examples.

## Deeper Digging

For a deeper digging you have to look at the _Mewa_ project itself and the implementation of [the main example language](example_language1.md), a strongly typed multiparadigm programming language with structures, classes, interfaces, free functions, generics, lambdas and exceptions. There exists an [FAQ](faq.md) that also tries to answer problem-solving questions.

## Preparation

The _Mewa_ program and the _Lua_ module are written in C++. Follow the instructions to install it.
The installation description is written for _Ubuntu_. For other platforms you might need to lookup the corresponding package names.

### Installation

To install _Mewa_ you need a C++ compiler with C++17 support. _Mewa_ is tested with _clang_ and _gcc_. 

#### Required system packages
##### For Lua 5.2
```Bash
lua5.2 liblua5.2-dev luarocks llvm llvm-runtime
```
##### For Lua 5.1
```Bash
lua5.1 liblua5.1-0-dev luarocks llvm llvm-runtime
```
#### Required luarocks packages
```Bash
luarocks install bit32
luarocks install penlight 
luarocks install LuaBcd
```
#### Build LuaBcd from sources (if luarocks install LuaBcd fails)
If the build of _LuaBcd_ with _luarocks_ fails, you can fetch the sources from _github_ and build it:
```Bash
git clone https://github.com/patrickfrey/luabcd.git
cd LuaBcd
./configure
make
make install
```
#### Fetch sources of latest release version
```Bash
git clone https://github.com/patrickfrey/mewa
cd mewa
git checkout -b `cat VERSION`
```
#### Configure to find Lua includes and to write the file Lua.inc included by make
```Bash
./configure
```
#### Build with GNU C/C++
```Bash
make COMPILER=gcc RELEASE=YES
```
#### Build with Clang C/C++
```Bash
make COMPILER=clang RELEASE=YES
```
#### Run tests
```Bash
make test
```
#### Install
```Bash
make install
```
#### Lua Environment
Don't forget to set the _Lua_ environment (LUA_CPATH,LUA_PATH) correctly when running the _Lua_ scripts from command line. 
You find a luaenv.sh in the archive of this article. Load it with.
```Bash
. tutorial/luaenv.sh
```


## Tutorial

In this tutorial we will learn how to use the typedb library with some self-contained examples.

### Declaring a variable

Let's start with a complicated example that is a substantial step forward. 
We print the LLVM code needed to assign a variable value to another variable. 
For this, we need to introduce **types** and **reductions**.

#### Introduction
##### Types
Types are items represented as integers. They are declared and retrieved by the name of the type and a context type.
The context type is itself a type or 0.
Global free variables have for example no associated context type and are declared with 0 as context type. 
Types are associated with a constructor. A constructor is a value, structure, or a function that describes the construction of the type.
Optionally, types can have parameters attached. Parameters are a list of type/constructor pairs. Types are declared with 
```Lua
typeid = typedb:def_type( contextType, name, constructor, parameters)
```
The ```typeid``` returned is the integer that represents the type for the _typedb_.
##### Reductions
Reductions are paths to derive a type from another. You can imagine the typesystem as a directed graph of vertices (types) and edges (reductions).
We will introduce some concepts that allow a partial view of this graph later. For now, imagine it as a graph.
Reductions have also an associated constructor. The constructor describes the construction of the type in the direction of the reduction from its source.
Here is an example:
```Lua
typedb:def_reduction( destType, srcType, constructor, 1)
```
The 1 as parameter is an integer value we will explain later.
##### Resolve Type
Types can be resolved by their name and a single or a list of context types, one having a path of reductions to the context type of the resolved type.
##### Derive type
Types can be constructed by querying a reduction path from one type to another and constructing the type from the source type constructor
by applying the list of constructors on this path. 

Let's have a look at the example:

#### Source
File examples/variable.lua
```Lua
$EXAMPLE:tutorial_variable
```
#### Output
```
$EXAMOUT:tutorial_variable
```
#### Conclusion
If you got here you got already quite far. We saw the application of an operator ('=') with an argument. 
Applying a function with more than one argument is imaginable. 
The first match of the operator was our candidate match chosen as a result. But selecting a match by other criteria is imaginable.
We declared a variable with a name, a concept of scope is missing here. We will look at scopes in the next example.


### Scope

Now let's see how scope is represented in the _typedb_.

#### Introduction
Scope in _Mewa_ is represented as a pair of non-negative integer numbers. The first number is the start, the first scope step that belongs to the scope, the second number the end, the first scope step that is not part of the scope. Scope steps are generated by a counter with increments declared in the grammar of your language parser.
All declarations in the _typedb_ are bound to a scope, all queries of the _typedb_ are bound to the current scope step. A declaration is considered to contribute to the result if its scope is covering the scope step of the query.

##### Set the current scope
```Lua
scope_old = typedb:scope( scope_new )
```
##### Get the current scope
```Lua
current_scope = typedb:scope()
```

The example is fairly artificial, but it shows how it works:

#### Source
File examples/scope.lua
```Lua
$EXAMPLE:tutorial_scope
```
#### Output
```
$EXAMOUT:tutorial_scope
```
#### Conclusion
This was easy, wasn't it? What is missing now is how the current scope step and scope are set. I chose the variant of treating it as an own aspect. 
The function used for the _AST_ tree traversal sets the current scope step and scope. This works for most cases. Sometimes you have to set the scope manually in nodes that implement declarations of different scopes, like for example function declarations with a function body in an own scope.


### Reduction Weight

Now we have to look again at something a little bit puzzling. We have to assign a weight to reductions. The problem is that even trivial examples of type queries lead to ambiguity if we do not introduce a weighting scheme that memorizes a preference. The ```typedb:resolve_type``` and ```typedb:derive_type``` functions are implemented as shortest path search that selects the result and implements this preference. Real ambiguity is something we want to detect as an error. An ambiguity is indicated when two or more results are appearing having the same weight sum.
I concluded that it is best to declare all reduction weights at one central place in the source and to document it well.

Let's have a look at an example without weighting of reductions that will lead to ambiguity. 

#### Failing example
File examples/weight1.lua
```Lua
$EXAMPLE:tutorial_weight1
```
#### Output
```
$EXAMOUT:tutorial_weight1
```
#### Adding weights
File examples/weight2.lua

Here is a diff with the edits we have to make for fixing the problem:
```
$EXAMPLE:tutorial_weight_diff
```
#### Output with weights
```
$EXAMOUT:tutorial_weight2
```
#### Conclusion
We introduced a 5th parameter of the ```typedb:def_reduction``` command that is 0 if not specified. 
This new parameter is meant to be declared in a way that it memorizes a preference of solution paths. 
The weights should be referenced by constants we declare at a central place where the trains of thought that led to the weighting schema are documented.


### Reduction Tag

The display of the typesystem as one graph is not enough for all cases. There are type derivation paths that are fitting in one case and undesirable in other cases. The following example declares an object of a class derived from a base class that calls a constructor function with no arguments. The constructor function is only declared for the base class. But when calling an object constructor an error should be reported if it does not exist for the class. The same behavior as for a method call is bad in this case.

Let's first look at an example failing:

#### Failing example
File examples/tags1.lua
```Lua
$EXAMPLE:tutorial_tags1
```
#### Output
```
$EXAMOUT:tutorial_tags1
```
#### Adding tags
File examples/tags2.lua

Here is a diff with the edits we have to make for fixing the problem:
```
$EXAMPLE:tutorial_tags_diff
```
#### Output with tags
```
$EXAMOUT:tutorial_tags2
```
#### Conclusion
We explained now the 4th parameter of the ```typedb:def_reduction``` defined as ```1``` in the first examples. It is the mandatory tag assigned to the reduction.
The command ```typedb.reduction_tagmask``` is used to declare named sets of tags selected for resolving and deriving types.

#### Remark
```typedb:derive_type``` has a second optional tag mask parameter that selects reductions to count and limit to a specified number, 1 by default.
The aim behind that is to allow restrictions on some classes of reductions. Most statically typed programming languages impose restrictions on the number of conversions of a parameter. The second tag mask helps you to implement such restrictions.  


### Objects with a Scope

In a compiler, we have building blocks that are bound to a scope. For example functions. These building blocks are best represented as objects. If we are in the depth of an _AST_ tree traversal we would like to have a way to address these objects without complicated structures passed down as parameters. This would be very error-prone. Especially in a non strictly typed language as _Lua_. 

#### Introduction
##### Define object instance in the current scope
```Lua
typedb:set_instance( name, obj)
```
##### Get the object instance of this or the nearest enclosing scope
```Lua
obj = typedb:get_instance( name)
```
##### Get the object instance declared of the current scope
```Lua
obj = typedb:this_instance( name)
```

#### Source
```Lua
$EXAMPLE:tutorial_env
```
#### Output
```
$EXAMOUT:tutorial_env
```
#### Conclusion
The possibility of attaching named objects to a scope is a big deal for readability, an important property for prototyping.
It brings structure into a system in an interpreter context where we have few possibilities to ensure safety by contracts.


### Control Structures, Implementing an IF
The next step is implementing an IF and to introduce a new class of type. 
Most programming languages require that the evaluation of a boolean expression stops when its outcome is determined.
An expression like ```if ptr && ptr->value()``` should not crash in the case ptr is a NULL pointer.

#### Introduction
For evaluating boolean expressions and as condition type of conditionals we define two new types.
##### Control True Type
This type has a field ```code``` that holds the code executed as long as it evaluates to true and a field ```out``` that holds an unbound label where the control branches to in case of evaluating to false.
##### Control False Type
This type is the mirror type of the control true type. It has a field ```code``` that holds the code that is executed as long as it evaluates to false and a field ```out``` that holds an unbound label where the control branches to in case of evaluating to true.
##### The IF statement
The IF takes the condition argument and transforms it into a control true type. The code of the resulting constructor is joined with the constructor code of the statements to evaluate in the case the condition is true. At the end, the unbound label is bound and declared at the end of the code.

#### Source
```Lua
$EXAMPLE:tutorial_control
```
#### Output
```
$EXAMOUT:tutorial_control
```

#### Conclusion
Control structures are implemented by constructing the control boolean types required. Boolean operators as the logical **AND** or the logical **OR** are constructed by wiring control boolean types together. This has not been done in this example, but it is imaginable after constructing an **IF**. The construction of types with reduction rules does not stop here. Control structures are not entirely different animals.

We have seen the whole variety of functions of the _typedb_ library now. The remaining functions not explained yet are convenient functions to set and get attributes of types. There is nothing substantial left to explain about the API though there is a lot more to talk about best practices and how to use this API.

I think we are now ready to look at our example compiler as a whole.


## Example Language Grammar

Now we will take a look at the grammar of the example language. 

### Parser Generator
_Mewa_ implements an _LALR(1)_ parser generator. The source file of the attributed grammar has 3 parts. 

  * Some configuration marked with a prefix '**%**'
  * The named lexems as a regular expression that matches the lexem value as argument.
  * An attributed grammar with keywords as strings and lexem or production names as identifiers

### Production Attribute Operators
The operator **>>** in the production attributes in oval brackets on the right side is incrementing the scope-step.
The operator **{}** in the production attributes is defining a scope range.

### Production Head Attributes
The attributes **L1**,**L2**,... are defining the production to be left associative with a priority specified as a number. 
The attributes **R1**,**R2**,... are defining the production to be right associative with a priority specified as a number. 

### Source
```
$EXAMPLE:tutorial_grammar
```


## Typesystem
Now let's overview the implementation of the typesystem module that generates the code.
The code shown now will be more organised, more complete, but in contrary to the tutorial not self-contained anymore.

In contrast to the example [language1](example_language1.md) the typesystem module has been splitted in several parts of maximum 100 lines of code to make them digestible. The snippets implementing helper functions are in the directory ```tutorial/sections```. The snippets implementing the functions attached to the _AST_ nodes are in the directory ```tutorial/ast```.

Because the amount of code in this part, we will not inspect it so closely as in the tutorial anymore. 
But I hope that after the tutorial you will still get a grip on the code shown.

### Header
Let's first take a look at the header of typesystem.lua. 

#### Submodule llvmir
The submodule ```llvmir``` implements all templates for the LLVM IR code generation. We sah such templates like ```{out} = load i32, i32* {this}``` with substututes in curly brackets in the examples of the tutorial. In the example compiler these templates are all declared in the module ```llvmir``` and referred to by name. The module ```llvmir``` has a submodule ```llvmir_scalar``` that is generated from a description of the scalar types of our language.

#### Submodule utils
The submodule ```typesystem_utils``` implements functions that are language independent. For example the function ```constructor_format``` that instantiated the llvmir code templates in the tutorial. It is implemented there in a more powerful form. String encoding, mangling, and _AST_ tree traversal functions are other examples there.

#### Global variables
The approach of _Mewa_ is not pure. Things are stored in the _typedb_ if it helps. For everything else we use global variables. The API of the _typedb_ is pragmatic and kept as minimal as reasonable. The header of ```typesystem.lua ``` has about a dozen global variables declared. In the example **language1** there are around 50 variables defined. For example ```typeDescriptionMap```, a map that associates every type with a table with the code generation templates for this type as members.

#### Source
```
$EXAMPLE:tutorial_typesystem
```

### Output
The output of out compiler front-end is printed with the functions ```print``` and ```print_section``` defined by the compiler. The function ```print``` is redirected to a function appending to the ```Code``` section of the output. The sections are variables in the [target files](../examples/target). The function ```print_section``` is appending to an output section specified as first parameter.

### AST Traversal
All _AST_ node functions participate in the traversal as it is in their responsibility to call the subnodes of the _AST_. I already mentioned in the tutorial that the current scope is implemented as own aspect and set by the _AST_ traversal function. The traversal functions are implemented in the ```typesystem_utils``` module. There are two variants of the traversal function:

  * ```function traverse( typedb, node, ...)```
  * ```function traverseRange( typedb, node, range, ...)```

The ```range``` is a pair of _Lua_ array indices ```{first, last element of the range}``` referring to the subnodes to process for a partial traversal. Partial traversal is used for processing the subnodes selectively. You may for example traverse the function name and the parameters first, then declare the function, and then traverse the function body for enabling recursion.
The variable arguments **...** are forwarded to the _AST_ node functions called. This way you can pass parameters down to the subnodes. The examples of _Mewa_ use parameters extensively. For example to pass down the declaration context that decides, wheter a variable declaration is member of a structure or a local or a global variable. Parameters are also used to implement multipass traversal or the _AST_ to parse declarations of a subtree, e.g. a class in a specific order. You pass down the index of the pass you want to process in an _AST_ node function. But be aware that this way of communicating is error prone. You should restrict it to a bare minimum and use scope bound data (```typedb:set_instance```, ```typedb:get_instance```) or even global variables instead.

##### Source from typesystem_utils
```Lua
-- Tree traversal helper function setting the current scope/step and calling the function of one node, and returning its result:
local function processSubnode( typedb, subnode, ...)
	local rt
	if subnode.call then
		if (subnode.scope) then
			local scope_bk,step_bk = typedb:scope( subnode.scope)
			typedb:set_instance( "node", subnode)
			if subnode.call.obj then rt = subnode.call.proc( subnode, subnode.call.obj, ...) else rt = subnode.call.proc( subnode, ...) end
			typedb:scope( scope_bk,step_bk)
		elseif (subnode.step) then
			local step_bk = typedb:step( subnode.step)
			if subnode.call.obj then rt = subnode.call.proc( subnode, subnode.call.obj, ...) else rt = subnode.call.proc( subnode, ...) end
			typedb:step( step_bk)
		else
			if subnode.call.obj then rt = subnode.call.proc( subnode, subnode.call.obj, ...) else rt = subnode.call.proc( subnode, ...) end
		end
	else
		rt = subnode.value
	end
	return rt
end
-- Tree traversal or a subrange of argument nodes, define scope/step and do the traversal call
function utils.traverseRange( typedb, node, range, ...)
	if node.arg then
		local rt = {}
		local start,last = table.unpack(range)
		local lasti,ofs = last-start+1,start-1
		for ii=1,lasti do rt[ ii] = processSubnode( typedb, node.arg[ ofs+ii], ...) end
		return rt
	else
		return node.value
	end
end
-- Tree traversal, define scope/step and do the traversal call
function utils.traverse( typedb, node, ...)
	if node.arg then
		local rt = {}
		for ii,subnode in ipairs(node.arg) do rt[ii] = processSubnode( typedb, subnode, ...) end
		return rt
	else
		return node.value
	end
end
```

### AST Node functions
Now we will visit the functions attchached to the _AST_ nodes. I split them into snippets covering different aspects. 
Most of the code is just delegating to functions we will inspect in the following section. 

#### Constants
Define atomic and structure constants in the source.

##### Structures, e.g. Initializer Lists
A structure has a list of type/constructor pairs as constructor. This resembles the parameter list of a function and that's what it is. For recursive initialization of objects from initializer lists, we declare a reduction from the type constexprStructureType to any object beeing initializable by a contant structure. The constructor is using the typedb to find a matching constructor with this list matching as parameter list. If it fails the constructor returns *nil* to indicate that it failed and that the solution relying on this reduction should be dropped. This kind of enveloping helps us to map initializer lists recursively.
```Lua
$EXAMPLE:tutorial_ast_constants
```

#### Variables
In this section are the node functions to define and query variables. These _AST_ node functions are just delegating to functions we will revisit later.
```Lua
$EXAMPLE:tutorial_ast_variables
```

#### Extern Function Declarations
Here are the extern function declarations with their parameters processed. The function ```typesystem.extern_funcdef``` calls the tree traversal to get the function name and the parameters. The collecting of the parameters is possible in different ways. Here a table is defined by the node that declares the parameter list, passed down as parameter to the recursive list declaration, and filled by the parameter declaration node ```typesystem.extern_paramdef```. The function call definition with ```defineFunctionCall``` is the same as for free functions and class methods.
```Lua
$EXAMPLE:tutorial_ast_extern
```

#### Data Types
This section defines classes, arrays and atomic data types. The function we have to discuss a little bit deeper here is ```typesystem.classdef```, the definition of a class:
 1. The context is changed. Whatever is passed to this _AST_ node function as context, we define a new context (```classContext```) to be passed down to the subnodes in the traversal. The context is a structure a field ```domain``` that tells if we are inside the definition of a class ("member"), if we are in the body of a function ("local"), or if we are not inside any structure ("global"). It has other fields too depending on the context. In classes it is also used to collect data (```structsize```,```members```) from its subnodes.
 2. The traversal of the subnodes has 4 passes. The index of the pass is passed down as parameter for the subnodes to decide what to do:
    * 1st Pass: Type Definitions
    * 2nd Pass: Member Variable Declarations
    * 3rd Pass: Method Declarations (the traversal calls 1st pass of function declarations)
    * 4th Pass: Method Implementation (the traversal calls the 2nd pass of function declarations)

The class node defines a multiple pass evaluation and the nodes ```typesystem.definition_2pass``` and ```typesystem.definition``` implement the gates that encapsulate the decision what is processed when.
 
```Lua
$EXAMPLE:tutorial_ast_types
```

#### Function Declarations
Now we have a look at functions with the parameters and the body. The traversal is split into two passes, the declaration and implementation as already mentioned in the data type section. A helper function ```utils.allocNodeData``` attaches the function description created in the first pass to the node. The function ```utils.getNodeData``` references it in the second pass. At the end of the 2nd pass the LLVM function declaration is printed to the output. The constructor of the function call and the function type with its parameters have already been declared in the 1st pass.

To mention is also the call of ```defineCallableEnvironment``` that creates a structure referred to as callable environment and binds it to the scope of the function body. We have seen in the tutorial how this works (Objects with a Scope). The callable environment structure contains all function related data like the return type, the register allocator, etc.
It is accessed with the function ```getCallableEnvironment```.

The _AST_ node function ```typesystem.callablebody``` collects the elements of the free function or class method description in the scope of the callable body. It collects the list of parameters in a similar way as the extern function declaration we have already seen.

```Lua
$EXAMPLE:tutorial_ast_functions
```

#### Operators
This section defines the the functions of _AST_ nodes implementing operators. The contruction of operators, member references, function calls are all redirected to the function ```applyCallable``` we will visit later. Function calls are implemented as operator "()" of a callable type.
The functions ```expectValueType``` and ```expectDataType``` used here are assertions.
```Lua
$EXAMPLE:tutorial_ast_operators
```

#### Control Structures
As we learned in the turorial, conditionals are implemented by wiring a control boolean type together with some code blocks. The control boolean type derived from the condition type with ```getRequiredTypeConstructor```.

The return node functions also use ```getRequiredTypeConstructor``` to derive the value returned from their argument. The return type is accessible in the callable environment structure.

```Lua
$EXAMPLE:tutorial_ast_controls
```

#### Blocks and the Rest
Finally we come to the section containing the blocks that do not fit somewhere else. 
  * The top level node, the program, that does some initializations of the language before further processing by delegation with the traversal of the subnodes.
  * The main program node, that does not do a lot here as there are no program arguments and no program return value implemented here. 
  * The node function ```typesystem.codeblock``` joins a list of statements to one constructor. 
  * The node function ```typesystem.free_expression``` makes a statement node from an expression node.

```Lua
$EXAMPLE:tutorial_ast_blocks
```

### Typesystem Functions
This chapter will survey the functions used in the AST node functions we have now seen. They are also split into snippets covering different aspects.

#### Reduction Weights
Here are all reduction weights of the reductions defined. We have explained the need for weighting reductions in the tutorial.
```Lua
$EXAMPLE:tutorial_section_reductionWeights
```

#### Reduction Tags and Tagmasks
This section defines all reduction tags and tagmasks. We have explained the need for tagging in the tutorial.
```Lua
$EXAMPLE:tutorial_section_reductionTagsAndTagmasks
```

#### Type Declaration String
This function provides a signature string of the type including context type and parameter types.
```Lua
$EXAMPLE:tutorial_section_declarationString
```

#### Calls and Promote Calls
Here are the functions to define calls with parameters and a return value. For first class scalar types we often need to look also at the 2nd argument to determine the constructor function to call. Most statically typed programming languages specify a multiplication of an interger with a floating point number as a multiplication of floating point numbers. If we define the operator dependent on the first argument, we have to define the call int * float as conversion of the first operand to a float followed by a float multiplication. I call these calls promote calls (promoting the first argument to the type of the second argument) in the examples. The integer argument is promoted to a float and then the constructor function of the float multiplication is called.
```Lua
$EXAMPLE:tutorial_section_defineCalls
```

#### Apply Constructors
This section defines the call of a constructor function. We got an impression of how this works in the tutorial (variable assignment). 
The functions ```tryApplyConstructor``` and ```applyConstructor``` are building a constructor by applying a constructor function on a list of arguments.
The functions ```tryApplyReductionList``` and ```applyReductionList``` are building a constructor from a chain of reductions applied on a base constructor.
The functions with a prefix ```try``` report a miss or an ambiguity with their return value instead of exiting with ```utils.errorMessage``` in case of an error.
```Lua
$EXAMPLE:tutorial_section_applyConstructors
```

#### Resolve Types
Here are the functions for resolving types, mapping types, and asserting type properties.
  * The function ```selectNoArgumentType``` filters a resolve type match without parameters, a variable or a data type.
  * The function ```resolveTypeFromNamePath``` resolves a type from a namespace or structure name path.
  * The function ```tryGetWeightedParameterReductionList``` get the reduction of for a parameter matching and its weight. The weight can be used to accumulate the weight of a function match as a whole to determine the best match. In the example languages, the maximum is used as accumulation function for the weight of the function match.
  * The function ```getRequiredTypeConstructor``` transforms a type into another type.

```Lua
$EXAMPLE:tutorial_section_resolveTypes
```
##### Note
The function ```getSeekContextTypes()``` called here is important to resolve types. It provides the list of the candidate context type/constructor pairs used to resolve a type. Inside a structure for example, it is allowed to access elements of this structure by name without a full namespace path of the element. But we can also access global types. Therefore we need to maintain a list of current context types that is extended on the entry into a structure and shrinked on exit.


#### Apply Callable
This section is the most complicated of the whole example compiler. 
It shows the code for how to find the best match of a callable with parameters. The candidates are fetched from a priority queue ordered by weight.
Constructor functions of the top candidates are called and if they succeed to build the objects then the match is returned.
Candidates with a failing constructor are dropped to enable recursive initializer structures.

The functions ```tryApplyCallable``` and ```applyCallable``` are provided for resolving all types with arguments (operators, member access, function call, etc.).
```Lua
$EXAMPLE:tutorial_section_applyCallable
```

#### Constructor Functions
Here are the building blocks for defining constructors.
  * The functions ```constructorParts```, ```constructorStruct``` and ```typeConstructorPairStruct''' are helpers for constructor or type/constructor pair structures.
  * The function ```callConstructor``` builds a constructor function from a format string and additional attributes. Most of the constructor functions of this example compiler are defined with ```callConstructor```. It uses the helper function ```buildCallArguments``` to build some format string variables for mapping the arguments of a constructor call.
```Lua
$EXAMPLE:tutorial_section_constructorFunctions
```

#### Define Function Call
The function ```defineFunctionCall``` introduced in this section is used to define a free function call or a method call as "()" operator with arguments on a callable.
A callable is an intermediate type created to unify all cases of a function call into one case. For example function variables may also be called with the arguments in oval brackets "(" ")". If we want to unify these cases, we cannot define a function as symbol with arguments, because the symbol binding is not available for a function variable. Therefore we define the function symbol to be of type callable with a "()" operator with the function parameter as arguments. The function variable can reference the callable as its type and also have a "()" operator with the function parameter as arguments.
```Lua
$EXAMPLE:tutorial_section_defineFunctionCall
```

#### Const Expression Types
Constants in the source trigger the creation of const expression types. Const expression types have their own implementation of operators. 
The const expression operator constructors do not produce code, but return a value as result. 
The constructor of a const expression is the value of the data item with this type.

```Lua
$EXAMPLE:tutorial_section_constexprTypes
```
##### Remark
The functions ```mewa.llvm_double_tohex``` or ```mewa.llvm_float_tohex``` are functions provided by the _Mewa_ library to convert floating point number constants into a binary representation needed by LLVM IR for floating point numbers that have no exact binary representation of a value writen with decimals, e.g. ```0.1```. This is not an ideal situation. The _Mewa_ library should not have any API bindings to LLVM. 

#### First Class Scalar Types
This section implements the creation of the first class scalar types from their descriptions in the module llvmir_scalar.lua. The string type, or better called string pointer type in this example language, is also defined here. As for the const expression types, we also define promote calls here, like integer + float implemented as float + float after _promotion_ of the left argument.

```Lua
$EXAMPLE:tutorial_section_firstClassScalarTypes
```

#### Variables
Here are the functions to declare variables of any kind depending on the context: local variables, global variables, member variables, function parameter, etc.
Most of the code is self explaining now.

One thing that is new is the use of the global variable ```localDefinitionContext``` as context type when defining local variables. Instead of the variable we could as well use 0. In a language implementing generics the value of localDefinitionContext can be set to an artificial type created for a generic instance because generic instances share scopes and the definition of different instances would otherwise interfere. 
```Lua
$EXAMPLE:tutorial_section_variables
```

#### Define Data Types
This section provides the functions to declare the data types of the example language, including structures and arrays.
The data types of the example language are fairly simple because the missing need of cleanup in case of failure.

The elementwise initializer of the class type and the array type are using the function ```applyCallable``` for the member initialization. 
This provides the recursive assignments of substructures.

The ```getOrCreateArrayType``` function is a seldom case where the current scope is set manually. The scope of the array type definition is set to the scope of the element type. The current scope is set back to the original after the  function completed its job.

```Lua
$EXAMPLE:tutorial_section_defineDataTypes
```

#### Context Types
The list of context types used for resolving types has already been explained. 
The function ```getDeclarationContextTypeId``` provides the access to the context type used for declarations depending on context.
The function ```getSeekContextTypes``` provides the access to the list context type used for ```typedb:resolve_type```.

The list of seek context types is also dependent on scope. When adding an element to a list not yet bound to the current scope then the list of the enclosing 
scope cloned calling ```thisInstanceTableClone( name, emptyInst)``` and the element is added to the clone. This comes into play when the ```self``` type is added to the list of context types. It is only visible in the methods body.

```Lua
$EXAMPLE:tutorial_section_contextTypes
```

#### Callable Environment
The callable environment bound to the scope of the function body has also been discussed.

To mention is the function ```expandMethodEnvironment``` that declares the ```self``` variable in a method body (explicit and implicit).
```Lua
$EXAMPLE:tutorial_section_callableEnvironment
```

#### Control Boolean Types
Here we have a complete definition of the control boolean types as introduced in the tutorial. The function definition has been taken one to one from the example **language1**. I think after our journey through the example, the code explains itself.

```Lua
$EXAMPLE:tutorial_section_controlBooleanTypes
```

#### Control Structures
Finally we visit the function ```conditionalIfElseBlock( node, condition, matchblk, elseblk, exitLabel)``` that is doing the work for the _AST_ node functions implementing the _if_ with or without the _else_. If we have an _else_ then we have to branch to the end and to bind the unbound label of the control true type. This is equivalent to turning the control true type to a control false type before adding the else block. 

```Lua
$EXAMPLE:tutorial_section_controlStructures
```

### Running the compiler
Finally or maybe with a quick jump to the end we got here. Now we build and run our compiler on the example source presented at the beginning.

```bash
cd examples
mkdir build

LUABIN=`which $ARG`
. tutorial/luaenv.sh

echo "Build the compiler ..."
mewa -b "$LUABIN" -g -o build/tutorial.compiler.lua tutorial/grammar.g
chmod +x build/tutorial.compiler.lua

echo "[1] Run the compiler on a test program ..."
build/tutorial.compiler.lua -o build/tutorial.program.llr tutorial/program.prg

echo "[2] Create an object file ..."
llc -relocation-model=pic -O=3 -filetype=obj build/tutorial.program.llr -o build/tutorial.program.o

echo "[3] Create an executable ..."
clang -lm -lstdc++ -o build/tutorial.program build/tutorial.program.o

echo "[4] Run the executable file build/tutorial.program"
build/tutorial.program

```
#### Output
```
[1] Run the compiler on a test program ...
[2] Create an object file ...
[3] Create an executable ...
[4] Run the executable file build/tutorial.program
Salary sum: 280720.00
```

### What is Missing
This article showed the implementation of a primitive language missing lots of features. For example:
  * Constructors implementing late binding, e.g. for implementing copy elision. In the example **language1** and in the [glossary](glossary.md) they are called unbound reference types.
  * More type qualifiers like const, private, etc.
  * Pointers
  * Dynamic memory allocation
  * Exceptions
  * Generics
  * Lambdas
  * Coroutines

And many more. You can visit the [FAQ](faq.md) to get an idea, how to implement a richer language.
You can dig into the main [example language1](example_language1.md) that implements many features missing here as example.

## Conclusion
We have seen how a very primitive compiler is written in _Lua_ using _Mewa_. 
We could compile and run a simple demo program in the shell.

I hope I could give you some overview about one way to write a compiler front-end.
Learning about another approach can be interesting, even if you go along another path.

_Mewa_ is based on very old ideas and offers nothing new. 
But it is a pragmatic approach that brings the implementation of a prototype of a non trivial compiler front-end for a single person within reach.






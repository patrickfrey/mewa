return {
	double = {
		def_local = "{out} = alloca double, align 8\n",
		def_local_val = "{out} = alloca double, align 8\nstore double {inp}, double* {out}, align 8",
		def_global = "{out} = internal global double 0.00000, align 8\n",
		def_global_val = "{out} = internal global double {inp}, align 8\n",
		default = "0.00000",
		llvmtype = "double",
		class = "fp",
		maxvalue = "1.8e+308",
		store = "store double {inp}, double* {out}, align 8",
		load = "{out} = load double, double* {adr}, align 8\n",
		advance = {"ulong", "long"},
		conv = {
			["float"] = {fmt="{out} = fpext float {inp} to double\n", weight=0},
			["ulong"] = {fmt="{out} = uitofp i64 {inp} to double\n", weight=0},
			["long"] = {fmt="{out} = sitofp i64 {inp} to double\n", weight=0},
			["uint"] = {fmt="{out} = uitofp i32 {inp} to double\n", weight=0},
			["int"] = {fmt="{out} = sitofp i32 {inp} to double\n", weight=0},
			["ushort"] = {fmt="{out} = uitofp i16 {inp} to double\n", weight=0},
			["short"] = {fmt="{out} = sitofp i16 {inp} to double\n", weight=0},
			["byte"] = {fmt="{out} = uitofp i8 {inp} to double\n", weight=0},
			["bool"] = {fmt="{1} = trunc i8 {inp} to i1\n{2} = zext i1 {1} to i32\n{out} = sitofp i32 {2} to double\n", weight=0}},
		unop = {
			["-"] = "{out} = fneg double {inp}\n"},
		binop = {
			["+"] = "{out} = fadd double {arg1}, {arg2}\n",
			["-"] = "{out} = fsub double {arg1}, {arg2}\n",
			["*"] = "{out} = fmul double {arg1}, {arg2}\n",
			["/"] = "{out} = fdiv double {arg1}, {arg2}\n",
			["%"] = "{out} = frem double {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = fcmp oeq double {arg1}, {arg2}\n",
			["!="] = "{out} = fcmp one double {arg1}, {arg2}\n",
			["<="] = "{out} = fcmp ole double {arg1}, {arg2}\n",
			["<"] = "{out} = fcmp olt double {arg1}, {arg2}\n",
			[">="] = "{out} = fcmp oge double {arg1}, {arg2}\n",
			[">"] = "{out} = fcmp ogt double {arg1}, {arg2}\n"}
	},
	float = {
		def_local = "{out} = alloca float, align 4\n",
		def_local_val = "{out} = alloca float, align 4\nstore float {inp}, float* {out}, align 4",
		def_global = "{out} = internal global float 0.00000, align 4\n",
		def_global_val = "{out} = internal global float {inp}, align 4\n",
		default = "0.00000",
		llvmtype = "float",
		class = "fp",
		maxvalue = "3.402823e+38",
		store = "store float {inp}, float* {out}, align 4",
		load = "{out} = load float, float* {adr}, align 4\n",
		advance = {"double", "ulong", "long", "uint", "int"},
		conv = {
			["double"] = {fmt="{out} = fptrunc double {inp} to float\n", weight=0.1},
			["ulong"] = {fmt="{out} = uitofp i64 {inp} to float\n", weight=0.1},
			["long"] = {fmt="{out} = sitofp i64 {inp} to float\n", weight=0.1},
			["uint"] = {fmt="{out} = uitofp i32 {inp} to float\n", weight=0},
			["int"] = {fmt="{out} = sitofp i32 {inp} to float\n", weight=0},
			["ushort"] = {fmt="{out} = uitofp i16 {inp} to float\n", weight=0},
			["short"] = {fmt="{out} = sitofp i16 {inp} to float\n", weight=0},
			["byte"] = {fmt="{out} = uitofp i8 {inp} to float\n", weight=0},
			["bool"] = {fmt="{1} = trunc i8 {inp} to i1\n{2} = zext i1 {1} to i32\n{out} = sitofp i32 {2} to float\n", weight=0}},
		unop = {
			["-"] = "{out} = fneg float {inp}\n"},
		binop = {
			["+"] = "{out} = fadd float {arg1}, {arg2}\n",
			["-"] = "{out} = fsub float {arg1}, {arg2}\n",
			["*"] = "{out} = fmul float {arg1}, {arg2}\n",
			["/"] = "{out} = fdiv float {arg1}, {arg2}\n",
			["%"] = "{out} = frem float {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = fcmp oeq float {arg1}, {arg2}\n",
			["!="] = "{out} = fcmp one float {arg1}, {arg2}\n",
			["<="] = "{out} = fcmp ole float {arg1}, {arg2}\n",
			["<"] = "{out} = fcmp olt float {arg1}, {arg2}\n",
			[">="] = "{out} = fcmp oge float {arg1}, {arg2}\n",
			[">"] = "{out} = fcmp ogt float {arg1}, {arg2}\n"}
	},
	ulong = {
		def_local = "{out} = alloca i64, align 8\n",
		def_local_val = "{out} = alloca i64, align 8\nstore i64 {inp}, i64* {out}, align 8",
		def_global = "{out} = internal global i64 0, align 8\n",
		def_global_val = "{out} = internal global i64 {inp}, align 8\n",
		default = "0",
		llvmtype = "i64",
		class = "unsigned",
		maxvalue = "18446744073709551616",
		store = "store i64 {inp}, i64* {out}, align 8",
		load = "{out} = load i64, i64* {adr}, align 8\n",
		advance = {"double", "long"},
		conv = {
			["double"] = {fmt="{out} = fptoui double {inp} to i64\n", weight=0},
			["float"] = {fmt="{out} = fptoui float {inp} to i64\n", weight=0},
			["long"] = {fmt="{out} = load i64, i64* {adr}, align 8\n", weight=0.1},
			["uint"] = {fmt="{out} = zext i32 {inp} to i64\n", weight=0},
			["int"] = {fmt="{out} = sext i32 {inp} to i64\n", weight=0.1},
			["ushort"] = {fmt="{out} = zext i16 {inp} to i64\n", weight=0},
			["short"] = {fmt="{out} = sext i16 {inp} to i64\n", weight=0.1},
			["byte"] = {fmt="{out} = zext i8 {inp} to i64\n", weight=0},
			["bool"] = {fmt="{out} = zext i1 {inp} to i64\n", weight=0}},
		unop = {
			["!"] = "{out} = xor i64 {inp}, -1\n"},
		binop = {
			["+"] = "{out} = add nuw i64 {arg1}, {arg2}\n",
			["-"] = "{out} = add nsw i64 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i64 {arg1}, {arg2}\n",
			["/"] = "{out} = udiv i64 {arg1}, {arg2}\n",
			["%"] = "{out} = urem i64 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl i64 {arg1}, {arg2}\n",
			[">>"] = "{out} = lshr i64 {arg1}, {arg2}\n",
			["&"] = "{out} = and i64 {arg1}, {arg2}\n",
			["|"] = "{out} = or i64 {arg1}, {arg2}\n",
			["^"] = "{out} = xor i64 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i64 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i64 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp ule i64 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp ult i64 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp uge i64 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp ugt i64 {arg1}, {arg2}\n"}
	},
	long = {
		def_local = "{out} = alloca i64, align 8\n",
		def_local_val = "{out} = alloca i64, align 8\nstore i64 {inp}, i64* {out}, align 8",
		def_global = "{out} = internal global i64 0, align 8\n",
		def_global_val = "{out} = internal global i64 {inp}, align 8\n",
		default = "0",
		llvmtype = "i64",
		class = "signed",
		maxvalue = "9223372036854775808",
		store = "store i64 {inp}, i64* {out}, align 8",
		load = "{out} = load i64, i64* {adr}, align 8\n",
		advance = {"double", "ulong"},
		conv = {
			["double"] = {fmt="{out} = fptosi double {inp} to i64\n", weight=0},
			["float"] = {fmt="{out} = fptosi float {inp} to i64\n", weight=0},
			["ulong"] = {fmt="{out} = load i64, i64* {adr}, align 8\n", weight=0.1},
			["uint"] = {fmt="{out} = zext i32 {inp} to i64\n", weight=0.1},
			["int"] = {fmt="{out} = sext i32 {inp} to i64\n", weight=0},
			["ushort"] = {fmt="{out} = zext i16 {inp} to i64\n", weight=0.1},
			["short"] = {fmt="{out} = sext i16 {inp} to i64\n", weight=0},
			["byte"] = {fmt="{out} = zext i8 {inp} to i64\n", weight=0.1},
			["bool"] = {fmt="{out} = zext i1 {inp} to i64\n", weight=0}},
		unop = {
			["-"] = "{out} = sub i64 0, {inp}\n"},
		binop = {
			["+"] = "{out} = add nsw i64 {arg1}, {arg2}\n",
			["-"] = "{out} = sub nsw i64 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i64 {arg1}, {arg2}\n",
			["/"] = "{out} = sdiv i64 {arg1}, {arg2}\n",
			["%"] = "{out} = srem i64 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl nsw i64 {arg1}, {arg2}\n",
			[">>"] = "{out} = ashr i64 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i64 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i64 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp sle i64 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp slt i64 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp sge i64 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp sgt i64 {arg1}, {arg2}\n"}
	},
	uint = {
		def_local = "{out} = alloca i32, align 4\n",
		def_local_val = "{out} = alloca i32, align 4\nstore i32 {inp}, i32* {out}, align 4",
		def_global = "{out} = internal global i32 0, align 4\n",
		def_global_val = "{out} = internal global i32 {inp}, align 4\n",
		default = "0",
		llvmtype = "i32",
		class = "unsigned",
		maxvalue = "4294967296",
		store = "store i32 {inp}, i32* {out}, align 4",
		load = "{out} = load i32, i32* {adr}, align 4\n",
		advance = {"double", "float", "long", "int"},
		conv = {
			["double"] = {fmt="{out} = fptoui double {inp} to i32\n", weight=0.1},
			["float"] = {fmt="{out} = fptoui float {inp} to i32\n", weight=0},
			["ulong"] = {fmt="{out} = trunc i64 {inp} to i32\n", weight=0.1},
			["long"] = {fmt="{out} = trunc i64 {inp} to i32\n", weight=0.2},
			["int"] = {fmt="{out} = load i32, i32* {adr}, align 4\n", weight=0.1},
			["ushort"] = {fmt="{out} = zext i16 {inp} to i32\n", weight=0},
			["short"] = {fmt="{out} = sext i16 {inp} to i32\n", weight=0.1},
			["byte"] = {fmt="{out} = zext i8 {inp} to i32\n", weight=0},
			["bool"] = {fmt="{out} = zext i1 {inp} to i32\n", weight=0}},
		unop = {
			["!"] = "{out} = xor i32 {inp}, -1\n"},
		binop = {
			["+"] = "{out} = add nuw i32 {arg1}, {arg2}\n",
			["-"] = "{out} = add nsw i32 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i32 {arg1}, {arg2}\n",
			["/"] = "{out} = udiv i32 {arg1}, {arg2}\n",
			["%"] = "{out} = urem i32 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl i32 {arg1}, {arg2}\n",
			[">>"] = "{out} = lshr i32 {arg1}, {arg2}\n",
			["&"] = "{out} = and i32 {arg1}, {arg2}\n",
			["|"] = "{out} = or i32 {arg1}, {arg2}\n",
			["^"] = "{out} = xor i32 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i32 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i32 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp ule i32 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp ult i32 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp uge i32 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp ugt i32 {arg1}, {arg2}\n"}
	},
	int = {
		def_local = "{out} = alloca i32, align 4\n",
		def_local_val = "{out} = alloca i32, align 4\nstore i32 {inp}, i32* {out}, align 4",
		def_global = "{out} = internal global i32 0, align 4\n",
		def_global_val = "{out} = internal global i32 {inp}, align 4\n",
		default = "0",
		llvmtype = "i32",
		class = "signed",
		maxvalue = "2147483648",
		store = "store i32 {inp}, i32* {out}, align 4",
		load = "{out} = load i32, i32* {adr}, align 4\n",
		advance = {"double", "float", "ulong", "uint"},
		conv = {
			["double"] = {fmt="{out} = fptosi double {inp} to i32\n", weight=0.1},
			["float"] = {fmt="{out} = fptosi float {inp} to i32\n", weight=0},
			["ulong"] = {fmt="{out} = trunc i64 {inp} to i32\n", weight=0.2},
			["long"] = {fmt="{out} = trunc i64 {inp} to i32\n", weight=0.1},
			["uint"] = {fmt="{out} = load i32, i32* {adr}, align 4\n", weight=0.1},
			["ushort"] = {fmt="{out} = zext i16 {inp} to i32\n", weight=0.1},
			["short"] = {fmt="{out} = sext i16 {inp} to i32\n", weight=0},
			["byte"] = {fmt="{out} = zext i8 {inp} to i32\n", weight=0.1},
			["bool"] = {fmt="{out} = zext i1 {inp} to i32\n", weight=0}},
		unop = {
			["-"] = "{out} = sub i32 0, {inp}\n"},
		binop = {
			["+"] = "{out} = add nsw i32 {arg1}, {arg2}\n",
			["-"] = "{out} = sub nsw i32 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i32 {arg1}, {arg2}\n",
			["/"] = "{out} = sdiv i32 {arg1}, {arg2}\n",
			["%"] = "{out} = srem i32 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl nsw i32 {arg1}, {arg2}\n",
			[">>"] = "{out} = ashr i32 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i32 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i32 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp sle i32 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp slt i32 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp sge i32 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp sgt i32 {arg1}, {arg2}\n"}
	},
	ushort = {
		def_local = "{out} = alloca i16, align 2\n",
		def_local_val = "{out} = alloca i16, align 2\nstore i16 {inp}, i16* {out}, align 2",
		def_global = "{out} = internal global i16 0, align 2\n",
		def_global_val = "{out} = internal global i16 {inp}, align 2\n",
		default = "0",
		llvmtype = "i16",
		class = "unsigned",
		maxvalue = "65536",
		store = "store i16 {inp}, i16* {out}, align 2",
		load = "{out} = load i16, i16* {adr}, align 2\n",
		advance = {"double", "float", "long", "int", "short"},
		conv = {
			["double"] = {fmt="{out} = fptoui double {inp} to i16\n", weight=0.1},
			["float"] = {fmt="{out} = fptoui float {inp} to i16\n", weight=0.1},
			["ulong"] = {fmt="{out} = trunc i64 {inp} to i16\n", weight=0.1},
			["long"] = {fmt="{out} = trunc i64 {inp} to i16\n", weight=0.2},
			["uint"] = {fmt="{out} = trunc i32 {inp} to i16\n", weight=0.1},
			["int"] = {fmt="{out} = trunc i32 {inp} to i16\n", weight=0.2},
			["short"] = {fmt="{out} = load i16, i16* {adr}, align 2\n", weight=0.1},
			["byte"] = {fmt="{out} = zext i8 {inp} to i16\n", weight=0},
			["bool"] = {fmt="{out} = zext i1 {inp} to i16\n", weight=0}},
		unop = {
			["!"] = "{out} = xor i16 {inp}, -1\n"},
		binop = {
			["+"] = "{out} = add nuw i16 {arg1}, {arg2}\n",
			["-"] = "{out} = add nsw i16 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i16 {arg1}, {arg2}\n",
			["/"] = "{out} = udiv i16 {arg1}, {arg2}\n",
			["%"] = "{out} = urem i16 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl i16 {arg1}, {arg2}\n",
			[">>"] = "{out} = lshr i16 {arg1}, {arg2}\n",
			["&"] = "{out} = and i16 {arg1}, {arg2}\n",
			["|"] = "{out} = or i16 {arg1}, {arg2}\n",
			["^"] = "{out} = xor i16 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i16 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i16 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp ule i16 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp ult i16 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp uge i16 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp ugt i16 {arg1}, {arg2}\n"}
	},
	short = {
		def_local = "{out} = alloca i16, align 2\n",
		def_local_val = "{out} = alloca i16, align 2\nstore i16 {inp}, i16* {out}, align 2",
		def_global = "{out} = internal global i16 0, align 2\n",
		def_global_val = "{out} = internal global i16 {inp}, align 2\n",
		default = "0",
		llvmtype = "i16",
		class = "signed",
		maxvalue = "32768",
		store = "store i16 {inp}, i16* {out}, align 2",
		load = "{out} = load i16, i16* {adr}, align 2\n",
		advance = {"double", "float", "ulong", "uint", "ushort"},
		conv = {
			["double"] = {fmt="{out} = fptosi double {inp} to i16\n", weight=0.1},
			["float"] = {fmt="{out} = fptosi float {inp} to i16\n", weight=0.1},
			["ulong"] = {fmt="{out} = trunc i64 {inp} to i16\n", weight=0.2},
			["long"] = {fmt="{out} = trunc i64 {inp} to i16\n", weight=0.1},
			["uint"] = {fmt="{out} = trunc i32 {inp} to i16\n", weight=0.2},
			["int"] = {fmt="{out} = trunc i32 {inp} to i16\n", weight=0.1},
			["ushort"] = {fmt="{out} = load i16, i16* {adr}, align 2\n", weight=0.1},
			["byte"] = {fmt="{out} = zext i8 {inp} to i16\n", weight=0.1},
			["bool"] = {fmt="{out} = zext i1 {inp} to i16\n", weight=0}},
		unop = {
			["-"] = "{out} = sub i16 0, {inp}\n"},
		binop = {
			["+"] = "{out} = add nsw i16 {arg1}, {arg2}\n",
			["-"] = "{out} = sub nsw i16 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i16 {arg1}, {arg2}\n",
			["/"] = "{out} = sdiv i16 {arg1}, {arg2}\n",
			["%"] = "{out} = srem i16 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl nsw i16 {arg1}, {arg2}\n",
			[">>"] = "{out} = ashr i16 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i16 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i16 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp sle i16 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp slt i16 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp sge i16 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp sgt i16 {arg1}, {arg2}\n"}
	},
	byte = {
		def_local = "{out} = alloca i8, align 1\n",
		def_local_val = "{out} = alloca i8, align 1\nstore i8 {inp}, i8* {out}, align 1",
		def_global = "{out} = internal global i8 0, align 1\n",
		def_global_val = "{out} = internal global i8 {inp}, align 1\n",
		default = "0",
		llvmtype = "i8",
		class = "unsigned",
		maxvalue = "256",
		store = "store i8 {inp}, i8* {out}, align 1",
		load = "{out} = load i8, i8* {adr}, align 1\n",
		advance = {"double", "float", "long", "int", "short", "bool"},
		conv = {
			["double"] = {fmt="{out} = fptoui double {inp} to i8\n", weight=0.1},
			["float"] = {fmt="{out} = fptoui float {inp} to i8\n", weight=0.1},
			["ulong"] = {fmt="{out} = trunc i64 {inp} to i8\n", weight=0.1},
			["long"] = {fmt="{out} = trunc i64 {inp} to i8\n", weight=0.2},
			["uint"] = {fmt="{out} = trunc i32 {inp} to i8\n", weight=0.1},
			["int"] = {fmt="{out} = trunc i32 {inp} to i8\n", weight=0.2},
			["ushort"] = {fmt="{out} = trunc i16 {inp} to i8\n", weight=0.1},
			["short"] = {fmt="{out} = trunc i16 {inp} to i8\n", weight=0.2},
			["bool"] = {fmt="{out} = zext i1 {inp} to i8\n", weight=0}},
		unop = {
			["!"] = "{out} = xor i8 {inp}, -1\n"},
		binop = {
			["+"] = "{out} = add nuw i8 {arg1}, {arg2}\n",
			["-"] = "{out} = add nsw i8 {arg1}, {arg2}\n",
			["*"] = "{out} = mul nsw i8 {arg1}, {arg2}\n",
			["/"] = "{out} = udiv i8 {arg1}, {arg2}\n",
			["%"] = "{out} = urem i8 {arg1}, {arg2}\n",
			["<<"] = "{out} = shl i8 {arg1}, {arg2}\n",
			[">>"] = "{out} = lshr i8 {arg1}, {arg2}\n",
			["&"] = "{out} = and i8 {arg1}, {arg2}\n",
			["|"] = "{out} = or i8 {arg1}, {arg2}\n",
			["^"] = "{out} = xor i8 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i8 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i8 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp ule i8 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp ult i8 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp uge i8 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp ugt i8 {arg1}, {arg2}\n"}
	},
	bool = {
		def_local = "{out} = alloca i8, align 1\n",
		def_local_val = "{out} = alloca i8, align 1\n{1} = zext i1 {inp} to i8\nstore i8 {1}, i8* {out}, align 1\n",
		def_global = "{out} = internal global i8 false, align 1\n",
		def_global_val = "{out} = internal global i8 {inp}, align 1\n",
		default = "false",
		llvmtype = "i1",
		class = "bool",
		maxvalue = "1",
		store = "{1} = zext i1 {inp} to i8\nstore i8 {1}, i8* {out}, align 1\n",
		load = "{1} = load i8, i8* {adr}, align 1\n{out} = trunc i8 {1} to i1\n",
		advance = {},
		conv = {
			["double"] = {fmt="{out} = fcmp une double {inp}, 0.000000e+00\n", weight=0.1},
			["float"] = {fmt="{out} = fcmp une float {inp}, 0.000000e+00\n", weight=0.1},
			["ulong"] = {fmt="{out} = cmp ne i64 {inp}, 0\n", weight=0.1},
			["long"] = {fmt="{out} = cmp ne i64 {inp}, 0\n", weight=0.1},
			["uint"] = {fmt="{out} = cmp ne i32 {inp}, 0\n", weight=0.1},
			["int"] = {fmt="{out} = cmp ne i32 {inp}, 0\n", weight=0.1},
			["ushort"] = {fmt="{out} = cmp ne i16 {inp}, 0\n", weight=0.1},
			["short"] = {fmt="{out} = cmp ne i16 {inp}, 0\n", weight=0.1},
			["byte"] = {fmt="{out} = cmp ne i8 {inp}, 0\n", weight=0}},
		unop = {
			["!"] = "{out} = xor i1 {inp}, true\n"},
		binop = {
			["&&"] = "{out} = and i1 {arg1}, {arg2}\n",
			["||"] = "{out} = or i1 {arg1}, {arg2}\n"},
		cmpop = {
			["=="] = "{out} = icmp eq i1 {arg1}, {arg2}\n",
			["!="] = "{out} = icmp ne i1 {arg1}, {arg2}\n",
			["<="] = "{out} = icmp ule i1 {arg1}, {arg2}\n",
			["<"] = "{out} = icmp ult i1 {arg1}, {arg2}\n",
			[">="] = "{out} = icmp uge i1 {arg1}, {arg2}\n",
			[">"] = "{out} = icmp ugt i1 {arg1}, {arg2}\n"}
	}
}
